---
title: "2020-03-19-cdr-analysis-all"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
# CdrS is required for cell division site placement but not elongation in hypersaline-adapted archaea. 

## This file contains all the code needed to recapitulate the figures for the manuscript. 
Input files are provided in the repository https://github.com/amyschmid/cdr/ 

### Install and load the packages to set up the coding environment
```{r}
# this is the function we will use to check for installed packages and load them. 
using<-function(...) {
    libs<-unlist(list(...))
    req<-unlist(lapply(libs,require,character.only=TRUE))
    need<-libs[req==FALSE]
    if(length(need)>0){ 
        install.packages(need)
        lapply(need,require,character.only=TRUE)
    }
}

using ("plyr", 
       "psychometric",
       "ggplot2",
       "tidyr",
       "dplyr",
       "tidyverse",
       "corrplot",
       "viridisLite",
       "viridis",
       "EnvStats",
       "stats",
       "patchwork", 
       "bestNormalize",
       "sjstats",
       "rstatix",
       "ggExtra",
       "ggpubr",
       "gplots",
       "lubridate",
       "grid",
       "maSigPro",
       "DataCombine",
       "gridExtra",
       "GenomicRanges",
       "rtracklayer",
       "GenomicFeatures",
       "trackViewer",
       "referenceIntervals",
       "effsize",
       "moderndive",
       "patchwork")
       

#maSigPro reference: Conesa, A., Nueda M.J., Alberto Ferrer, A., Talon, T. 2006. maSigPro: a Method to Identify Significant Differential Expression Profiles in Time-Course Microarray Experiments. Bioinformatics 22, 1096-1102

```

### Transcriptional analysis, Figure 1

#### Load data and select the relevant genes 
```{r}
m <- read.delim ("GE-dulmage.txt", sep = "\t") 

#this file is too large to host on github. Download the file from the Duke Digital Repository at  https://dx.doi.org/10.7924/r4pz54w7h. Click on "Expression" on the front page, then download the file "1154_normalized_GE_data.csv". Use "read.csv" command to load this file.

#If you use gene expression data from that repository in a publication, please cite the source article: 
#Copy number variation is associated with gene expression change in archaea
#Keely A. Dulmage, Cynthia L. Darnell, Angie Vreugdenhil, and Amy K. Schmid1 Microb Genom. 2018 Sep; 4(9): e000210. doi: 10.1099/mgen.0.000210

#subset 
g<-c("VNG0194H", "VNG0195H", "VNG0192G")
m.g <- subset(m, gene %in% g)

```


#### Make subpanel 1B
```{r}
#get the output pdf set up an specify a rectangular output image
pdf("geplot.pdf", width = 6, height = 4)

#plot just to see what it looks like
matplot(t(m.g[3,]), type = "l", col = c("light green"), lty = 1, lwd = 1, na.rm = TRUE, axes = FALSE, xlab = "", ylab = "")
par(new = TRUE)
matplot (t(m.g[1:2,]), type = "l", lty = 1, lwd = 1, col = c("purple", "blue"), xlab = "Condition number", ylab = "Expression ratio (log10)")

#make a legend
legend(-0.5,3.5, legend = c("ftsZ2", "cdrS", "cdrL"), bty="n", lty = 1, lwd = 2, col = c("purple", "blue","light green"), text.font = c(3,3,3))

#output the pdf
dev.off()

```


#### Calculate correlations described in the text for S, Z, L, trmB across all conditions
```{r}
gwt <-c("VNG0194H", "VNG0195H", "VNG0192G", "VNG1451C")
m.gwt <- subset(m, gene %in% gwt)
t.mgwt <- (t(m.gwt))
colnames(t.mgwt)<-t.mgwt[1, ]
t.mgwt<-t.mgwt[-1, ]
write.csv (t.mgwt, file = "LSZT_array_transpose.csv")
```

```{r}
t.mg.numeric<-data.matrix(read.csv("LSZT_array_transpose.csv"))
colnames(t.mg.numeric)<-c("condition", "ftsZ2", "cdrS", "cdrL", "trmB")
mycors <- cor(t.mg.numeric[ ,2:5])
#summary(mycors)
mycors



#visualize the correlations (included via text rather than graphic in ms)
#pdf("corrplot.pdf")
#corrmap <- corrplot(mycors, method = "circle",
                     #col = colorRampPalette(c("lightgoldenrod4", "white", "midnightblue"))(100),
                     #type = "lower", order = "hclust", number.cex = 2,
                     #addCoef.col = "black", cl.pos = "b",
                     #tl.col = "black", tl.srt = 45, tl.cex = 1.5,
                     #diag = FALSE)
#dev.off()


```

#### Calculate CIs
```{r}
CIr(r = 0.9235775, n = 1154, level = 0.95) #CI of Z vs S

CIr(r = 0.2986511, n = 1154, level = 0.95) #CI of Z vs L

CIr(r = -0.2913172, n = 1154, level = 0.95) #CI of Z with trmB

CIr(r = 0.2750325 , n = 1154, level = 0.95) #CI of S with L

CIr(r =-0.27474541 , n = 1154, level = 0.95) #CI of S with trmB

CIr(r = -0.02217327 , n = 1154, level = 0.95) #CI of L with trmB
```

#### Make subpanels

##### Plot subpanel C
Zoom-ins to show conditions where LSZ are co-expressed, and where L is not co-expressed with SZ
```{r}
#subset to select the conditions in which genes are co-expressed
m.g.c<-m.g %>% dplyr::select(contains("co__")) #yes
m.g.n<-m.g %>% dplyr::select(contains("Ni"))
m.g.m<-m.g %>% dplyr::select(contains("Mn"))
m.g.cu<-m.g %>% dplyr::select(contains("Cu__"))
m.g.zn<-m.g %>% dplyr::select(contains("Zn"))

#select all the columns that have metal and oxidative stress: H2O2, PQ, Mn, Ni, Co, 
m.g.stress<-cbind(m.g.c, m.g.n, m.g.m, m.g.cu, m.g.zn)

#set up pdf
pdf("geplot-stress-ZSLcorr.pdf", width = 6, height = 4)

#plot
matplot(t(m.g.stress), type = "l", lty = 1, lwd = 1, col = c("purple", "blue", "light green"), xlab = "Condition number", ylab = "Expression ratio (log10)")

#output
dev.off()

```

##### For these metal stress conditions, correlate SZ vs L 
```{r}
#First treat SZ as one unit, since they're almost always correlated with each other. 
sz<-m.g.stress[1:2, ]
sz.mean<-apply(sz, 2, mean)
l<-m.g.stress[3, ]
l.mean<-apply(l,2,mean)
cor (sz.mean, l.mean)

dim(m.g.stress)

```

##### Calculate the significance of the correlation SZ to L
```{r}

#calculate the significance of the correlation using psycometric package
#sample size is the number of columns - i.e. dim(m.g.o) = 58

CIr(r = 0.7710611, n = 50, level = 0.95)
```


##### Plot conditions where SZ and L are not as well correlated (e.g. rapid growth)
```{r}

m.g.o<-m.g %>% dplyr::select(contains("o2_set")) #no


#set up pdf
pdf("geplot-nonstress.pdf", width = 6, height = 4)

#plot
matplot(t(m.g.o), type = "l", lty = 1, lwd = 1, col = c("purple", "blue", "light green"), xlab = "Condition number", ylab = "Expression ratio (log10)")



#output
dev.off()

```

##### For these non-stress conditions, correlate SZ vs L 
```{r}
#calculate correlation for non-stress

sz.grow<-m.g.o[1:2, ]
sz.mean.g<-apply(sz.grow, 2, mean)
l.grow<-m.g.o[3, ]
l.mean.g<-apply(l.grow,2,mean)
cor (sz.mean.g, l.mean.g)
dim(m.g.o)
```

##### Calculate the significance of the correlation SZ to L
```{r}
#calculate the significance of the correlation using psycometric package
#sample size is the number of columns - i.e. dim(m.g.o) = 58

CIr(r = -0.1583029, n = 58, level = 0.95)
```


### Bulk culture microscopy and growth analysis, Figure 2

#### Read in the data and format appropriately
```{r}
#CFU data
data.cfu <- read.csv("ODCFU.csv", header=TRUE)
data.cfu <- filter(data.cfu, Strain != 'VNG0195H') %>% droplevels()

data_rep <- filter(data, Strain == 'ura3')
data_rep$Strain <- 'ura3B'

data.cfu <- rbind(data, data_rep)
data.cfu$group <- ifelse(data.cfu$Strain %in% c('ura3', 'ftsZ2'), 'A', 'B')

data_subset <- filter(data, OD < 0.2)

#growth data
growth <- read.csv("growth.csv", header=TRUE)

#cell length data
data.len <- read.csv('Growth_curve_length.csv', header = TRUE)
data.len <- as.data.frame(data.len)
data.len <- filter(data.len, Strain != 'cdrL') %>% droplevels()
data.len$Strain <- factor(data.len$Strain, levels = c('ura3', 'cdrS', 'ftsZ2'))
data.len$Growth_phase <- factor(data.len$Growth_phase, 
                            levels = c('earlylog', 'midlog', 'earlysta', 'sta'))



#cell area data
data.ar <- read.csv('Growth_curve_area.csv', header = TRUE)
data.ar <- as.data.frame(data.ar)
data.ar <- filter(data.ar, Strain != 'cdrL') %>% droplevels()
data.ar$Strain <- factor(data.ar$Strain, levels = c('ura3', 'cdrS', 'ftsZ2'))
data.ar$Growth_phase <- factor(data.ar$Growth_phase, levels = c('earlylog', 'midlog', 'earlysta', 'sta'))


```

#### Make the plot for Supplementary Figure 2
```{r}
group.colors <- c(ura3="#000000", cdrS="#2f738c", ftsZ2="#441152")

growth_phase.labs <- c('Early log phase', 'Midlog phase', 
                       'Early stationary phase', 'Stationary phase')
names(growth_phase.labs) <- c('earlylog', 'midlog', 'earlysta', 'sta')


strain.labs <- c('ura3', 'cdrS', 'ftsZ2')
names(strain.labs) <- c('ura3', 'cdrS', 'ftsZ2')

ggplot(data.len) +
  geom_density(aes(x = Length, y = ..density.., fill = Strain, color = Strain), 
               alpha = 0.65, show.legend = FALSE, lwd = 0.2) +
  scale_x_continuous(expand = c(0, 0), limits = c(0, 60)) +
  scale_y_continuous(expand = c(0, 0)) +
  theme_bw() +
  labs(x=expression(paste("Length (", mu, "m)", sep = "")), y = 'Relative frequency') +
  facet_grid(rows = vars(Strain), cols = vars(Growth_phase),
             labeller = labeller(Growth_phase = growth_phase.labs,
                                 Strain = strain.labs)) +
  scale_color_manual(values = group.colors) +
  scale_fill_manual(values = group.colors) +
  theme(panel.background = element_blank(), panel.grid = element_blank(),
        panel.spacing = unit(1, "lines"), strip.text.y = element_text(face = 'italic')) +
  NULL

ggsave('cell_length_all.pdf', height = 5, width = 7, dpi = 600)
```

#### Make the plot for Figure 2A
```{r}
### set up geomeans for early log plot
ura3_geomean <- aggregate(Length ~ Growth_phase, 
                          data = filter(data.len, Strain == "ura3"), geoMean)
ura3_sd <- aggregate(Length ~ Growth_phase, 
                     data = filter(data.len, Strain == "ura3"), sd)

early_log_data <- filter(data.len, Growth_phase == 'earlylog')
mid_log_data <- filter(data.len, Growth_phase == 'midlog')
early_sta_data <- filter(data.len, Growth_phase == 'earlysta')
sta_data <- filter(data.len, Growth_phase == 'sta')


early_log_geomean <- filter(ura3_geomean, Growth_phase == "earlylog")
early_log_sd <- filter(ura3_sd, Growth_phase == "earlylog")
mean_line <- early_log_geomean$Length
mean_plus <- early_log_geomean$Length + early_log_sd$Length
mean_minus <- early_log_geomean$Length - early_log_sd$Length


ggplot(early_log_data, aes(x = Length, fill = Strain, color = Strain)) +
  annotate("rect", xmin = mean_minus, xmax = mean_plus, ymin = 0, ymax = Inf,
           alpha = 0.5, fill = "#C0C0C0") +
  geom_density(alpha = 0.75, show.legend = FALSE, lwd = 0.5) +
  geom_rug(sides = "b", alpha = 0.4, length = unit(0.1, "npc"), 
           show.legend = FALSE) +
  scale_x_continuous(expand = c(0, 0), 
                     breaks = seq(0, 80, by = 20)) +
  scale_y_continuous(limits = c(0, 0.20),
                     expand = c(0, 0.03),
                     breaks = seq(0, 0.15, by = 0.05)) +
  theme_minimal() +
  theme(text = element_text(size = rel(5)), 
        panel.grid.major.y = element_blank(),
        panel.grid.minor.y = element_blank()) +
  scale_color_manual(values = group.colors) +
  scale_fill_manual(values = group.colors) +
  labs(x=expression(paste("Length (", mu, "m)", sep = "")),
       y = "Relative frequency") +
  geom_vline(aes(xintercept = mean_line), linetype = 2) +
  facet_grid(Strain ~ .) +
  NULL

ggsave("early_log_length_dist.pdf", width = 12, height = 22, dpi = 300)
```
#### Calculate the length geometric means and summary stats reported in main text and Table 1.
```{r}
stats.len <- ddply(data.len, .(Growth_phase, Strain), summarize, geomean = geoMean(Length), sd = sd(Length), nobs = length(Length), sem = (sd(Length)/sqrt(nobs)))

stats.len

```
#### Calculate the area geometric means and summary stats reported in main text and Table 1.
```{r}
stats.area <- ddply(data.ar, .(Growth_phase, Strain), summarize, geomean = geoMean(Area), sd = sd(Area), nobs = length(Area), sem = (sd(Area)/sqrt(nobs)))

stats.area

```

#### Detect the significance of the difference between the geomeans of the distribution of parent vs mutant cells in each growth phase
```{r}
# statistical tests. 
qqPlot(data.ar$Area) 
qqPlot(data.len$Length) # not normally distributed. Given the critical limit theorem, can use parametric tests because >200 observations for each strain. But distribution is highly skewed. Try with data transform.

```


##### decide on best transform
```{r}
len.checknorm<-bestNormalize(data.len$Length) #check which transformation is best.
len.checknorm$chosen_transform #Ordered quantile normalization (OQN) is best normalization strategy
len.checknorm$norm_stats #look at the information about the distributions following each transform


ar.checknorm<-bestNormalize(data.ar$Area) #check which transformation is best.
ar.checknorm$chosen_transform #Ordered quantile normalization (OQN) is best normalization strategy
ar.checknorm$norm_stats #look at the information about the distributions following each transform
```

#### Perform OQN on the length and area data
```{r}
area.n<-orderNorm(data.ar$Area)
data.ar$oqn.area<-predict(area.n)
hist(data.ar$oqn.area, breaks = 20)
# data forced to normal distribution.

len.n<-orderNorm(data.len$Length)
data.len$oqn.len<-predict(len.n)
hist(data.len$oqn.len, breaks = 20)
# data forced to normal distribution.
```

#### Pairwise Welch's test and effect size calculations on oqn-normalized hv and hm areas
```{r}
#subset length data
data.len.elog.s<-filter(data.len, Strain == "cdrS", Growth_phase == "earlylog")
data.len.elog.u<-filter(data.len, Strain == "ura3", Growth_phase == "earlylog")
data.len.elog.z<-filter(data.len, Strain == "ftsZ2", Growth_phase == "earlylog")

#perform tests on length data differences between strains
t.test(data.len.elog.s$oqn.len, data.len.elog.u$oqn.len, p.adjust.method = "BH", pool.sd = FALSE)
t.test(data.len.elog.z$oqn.len, data.len.elog.u$oqn.len, p.adjust.method = "BH", pool.sd = FALSE)

#subset area data
data.ar.elog.s<-filter(data.ar, Strain == "cdrS", Growth_phase == "earlylog")
data.ar.elog.u<-filter(data.ar, Strain == "ura3", Growth_phase == "earlylog")
data.ar.elog.z<-filter(data.ar, Strain == "ftsZ2", Growth_phase == "earlylog")

#perform tests on length data differences between strains
t.test(data.ar.elog.s$oqn.area, data.ar.elog.u$oqn.area, p.adjust.method = "BH", pool.sd = FALSE)
t.test(data.ar.elog.z$oqn.area, data.ar.elog.u$oqn.area, p.adjust.method = "BH", pool.sd = FALSE)

```

##### Given the large n, calculate effect size of difference between mothers, then difference between daughters.
```{r}
#put cell length data in format for effect size calc
oqnlen <- as.data.frame(cbind(data.len.elog.u$oqn.len, data.len.elog.s$oqn.len, data.len.elog.z$oqn.len))
colnames(oqnlen) <- c("ura3", "cdrs", "ftsz2")

#calc effect size
cohen.d(oqnlen$cdrs, oqnlen$ura3, paired = FALSE)
cohen.d(oqnlen$ftsz2, oqnlen$ura3, paired = FALSE)


#put cell area data in format for effect size calc
oqnar <- as.data.frame(cbind(data.ar.elog.u$oqn.area, data.ar.elog.s$oqn.area, data.ar.elog.z$oqn.area))
colnames(oqnar) <- c("ura3", "cdrs", "ftsz2")

#calc effect size
cohen.d(oqnar$cdrs, oqnar$ura3, paired = FALSE)
cohen.d(oqnar$ftsz2, oqnar$ura3, paired = FALSE)

```

#### Make the plot for Figure 2B
```{r}

ggplot(growth)+
  geom_point(aes(x=X, y=ura3), color="#000000", shape =21, size = 2)+
  geom_smooth(se=growth$ura3_SE, aes(x=X, y=ura3), color="#000000", fill="#000000", alpha = 0.5, lwd = 1)+
  
  geom_point(aes(x=X, y=VNG0194H), color="#2f738c", shape = 21, size = 2)+
  geom_smooth(se=growth$VNG0194H_SE, aes(x=X, y=VNG0194H), color="#2f738c", fill="#2f738c", alpha = 0.5, lwd = 0.5)+
  
  geom_point(aes(x=X, y=ftsZ2), color="#441152", shape = 21, size = 2)+
  geom_smooth(se=growth$ftsZ2_SE, aes(x=X, y=ftsZ2), color="#441152", fill="#441152", alpha = 0.5, lwd = 0.5)+
  
  
  theme_bw()+
  scale_y_log10()+
  labs(x="Time (hours)", y="Cell Density (OD600)")+
  theme(axis.title=element_text(size=14), axis.text=element_text(size=12))
  
ggsave("2020-04-03-growth_curve.pdf", width=7.5, height=4)

```

#### Calculate correlation and significance of correlation between the OD vs CFU slopes for each strain
```{r}
#these correlations are described in the main text
ura3_data <- filter(data, Strain == 'ura3')
cdrS_data <- filter(data, Strain == 'VNG0194H')
ftsZ2_data <- filter(data, Strain == 'ftsZ2')

cor.test(ura3_data$CFUlog10, ura3_data$ODlog2)
cor.test(cdrS_data$CFUlog10, ura3_data$ODlog2)
cor.test(ftsZ2_data$CFUlog10, ftsZ2_data$ODlog2)

```


#### Make plot, figure 2C
```{r}
#this plot shows the independent correlations for each strain

group.colors <- c(ura3 = "#000000", VNG0194H = "#2f738c", 
                  ftsZ2 = "#441152", ura3B = '#000000')

ggplot(data, aes(x = ODlog2, y = CFUlog10, color = Strain, fill = Strain)) +
  theme_light() +  
  theme(panel.grid = element_blank(),
        legend.position = 'none',
        strip.background = element_blank(),
        strip.text.x = element_blank(),
        axis.text = element_text(size = 12),
        axis.title = element_text(size = 14)) +
  geom_point(size=2, alpha=0.75) +
  geom_smooth(method = lm, fullrange = TRUE) +
  scale_color_manual(values = group.colors) +
  scale_fill_manual(values = group.colors) +
  facet_grid(. ~ group) +
  labs(x = expression(Log[2]~~OD[600]),
       y = expression(Log[10]~~CFU/ml)) +
  NULL

ggsave("OD_CFU_ind_corr.pdf", width=5, height=3)

```

#### Statistical tests to detect significant differences in OD vs CFU correlation of the ∆cdrS, ∆ura3, ∆ftsZ2 strains

##### First run linear model to see if slopes of OD vs CFU are similar enough between strains to compare

```{r}

# Test to see if different slopes are needed for two strains
# Very high p-value for ODlog2: strain 2-way interaction indicates independence between strains, thus directly comparing equal slopes is quite reasonable.

summary(aov(CFUlog10 ~ ODlog2 * Strain, 
            data = filter(data_subset, group == "A")))

#
equalslopes.mod <- lm(CFUlog10 ~ ODlog2 + Strain, 
                      data = filter(data_subset, group == "A"))
summary(equalslopes.mod)


summary(aov(CFUlog10 ~ ODlog2 * Strain, 
            data = filter(data_subset, group == "B")))

#
equalslopes.mod <- lm(CFUlog10 ~ ODlog2 + Strain, 
                      data = filter(data_subset, group == "B"))
summary(equalslopes.mod)


# We then fit a linear model using log2(OD) and Strain to predict log10(CFU).
# When allowing an interaction between Strain and log2(OD), the p-value for that
# term was very large (~0.95) indicating no evidence that an
# interaction was needed. A new model was fit that required equal slopes for the
# regression line of each strain. The model was:

# ftsZ2:  log10(CFU) = 7.09         + 0.34 * log2(OD)
# ura3:      log10(CFU) = 7.09 + 0.334 + 0.34 * log2(OD)

# Thus, the predicted log10(CFU) is 0.334 higher for URA3 than for ftsZ2
# To convert this from a log10 scale, we need to raise 10 to the power of both
# sides of the equation. That looks like this:

# ftsZ2:  CFU = 10^7.09            * 10^(0.34 * log2(OD))
# ura3:      CFU = 10^7.09 * 10^0.334 * 10^(0.34 * log2(OD))

# This shows that the predicted CFU is 10^0.334 (or 2.159) times higher for ura3
# than for ftsZ2. 

# Model calculated similarly for cdrS vs ura3.

```

### Aphidocholin microscopy analysis, Figure 3

#### Read in the data and get it ready for plotting
```{r}

data00 <- read.csv("time00data.csv", header=TRUE)
data06 <- read.csv("time06data.csv", header=TRUE)
data17 <- read.csv("time17data.csv", header=TRUE)

data00 <- mutate(data00, Condition = "Time00")
data06 <- mutate(data06, Condition = "Time06")
data17 <- mutate(data17, Condition = "Time17")

data_A <- dplyr::union(data00, data06)
data.aph <- dplyr::union(data_A, data17)

data.aph$Strain_ordered = factor(data.aph$Strain, levels=c("ura3", "cdrS", "Scomp"))
data.aph$Condition_rev = factor(data.aph$Condition, levels = c("Time17", "Time06", "Time00"))
group.colors <- c(ura3="#000000", cdrS="#2f738c", Scomp="#b8860b")
```


#### Calculate geometric means of cell area
```{r}
geomeans <- ddply(data.aph, .(Condition, Strain), summarize, Area_micron.geomean = geoMean(Area_micron))
data_new <- left_join(data.aph, geomeans, by = c("Condition", "Strain"))

label_names <- c(
  Time00 = "Pre-aphidicolin",
  Time06 = "6 hours post-addition", 
  Time17 = "11 hours post-washout"
  )


write.table (geomeans, file = "aph.geomeans.txt", sep= "\t")
```


#### Plot - Figure 3
```{r}

ggplot(data_new, aes(x = Area_micron, fill = Condition, colour = Condition)) +
  geom_density(alpha = 0.6) +
  scale_x_continuous(limits = c(0, 40), expand = c(0, 0)) +
  scale_y_continuous(limits = c(0, 0.3), expand = c(0, 0)) +
  facet_grid(Strain_ordered ~ ., labeller = labeller(.cols = label_both)) +
  theme_minimal() +
  theme(text=element_text(colour="black"),
        plot.background=element_rect(fill="white"),
        panel.background=element_rect(fill="white", colour="black"), 
        panel.grid.major=element_blank(),
        panel.grid.minor=element_blank(),
        axis.text=element_text(color="black", size=10),
        axis.ticks.y.left=element_line(colour="black"),
        axis.title.y=element_text(size=14)) +
  labs(x=expression("Area ("*mu*m^2*")"), y = "Relative frequency") +
  geom_vline(aes(xintercept = Area_micron.geomean, colour = Condition),  
             linetype = "dashed") +
  scale_color_viridis_d(begin = 0, end = .8, aesthetics = c("fill", "colour"), 
                        option = "plasma") 

```

#### Perform statistical tests to determine the significance of the difference between the means of each distribution


```{r}
# test for normality
qqPlot(data.aph$Area_micron) # not normally distributed. Given the critical limit theorem, could use parametric tests because >200 observations for each strain. But distribution is so highly skewed that it's better to try with data transform.

```


##### decide on best transform
```{r}
aph.checknorm<-bestNormalize(data.aph$Area_micron) #check which transformation is best.
aph.checknorm$chosen_transform #Ordered quantile normalization (OQN) is best normalization strategy
aph.checknorm$norm_stats #look at the information about the distributions following each transform
```

#### Perform OQN on the length and area data
```{r}
aph.n<-orderNorm(data.aph$Area_micron)
data.aph$oqn.area<-predict(aph.n)
hist(data.aph$oqn.area, breaks = 20)
# data forced to normal distribution.

```

##### Run the test
```{r}
#design is 2x2 mixed 
#IV between: Strain
#IV within: Condition (time point)
#DV: area 

#add sample ids to each treatment
data$id <- 1:nrow(data.aph)

#convert time dependent variable to a factor
data.aph$time<-as.factor(data.aph$Condition)


aov_strain_time <- aov(oqn.area ~ Strain*Condition + Error(Label/time), data=data.aph)
summary(aov_strain_time) 

#Results suggest that the strains are different (between group), that each strain is affected over time (within group), but that there is no interaction between the two groups. Suggests a simple main effect. Run post-hoc tests for each of Strain across time.
```
##### Post-hoc tests


#### Pairwise Welch's test and effect size calculations on oqn-normalized hv and hm areas
```{r}
#subset area data
data.aph.s<-filter(data.aph, Strain == "cdrS")
data.aph.scomp<-filter(data.aph, Strain == "Scomp")
data.aph.u<-filter(data.aph, Strain == "ura3")
data.aph.t1<-filter (data.aph, Condition == "Time00")
data.aph.t2<-filter (data.aph, Condition == "Time06")
data.aph.t3<-filter (data.aph, Condition == "Time17")

#perform tests on area data differences between time points for each strain
pairwise.t.test(data.aph.s$oqn.area, data.aph.s$Condition, p.adjust.method = "BH", pool.sd = FALSE)
pairwise.t.test(data.aph.scomp$oqn.area, data.aph.scomp$Condition, p.adjust.method = "BH", pool.sd = FALSE)
pairwise.t.test(data.aph.u$oqn.area, data.aph.u$Condition, p.adjust.method = "BH", pool.sd = FALSE)

#perfrom tests on area data differences between strains at each time point
pairwise.t.test(data.aph.t1$oqn.area, data.aph$Strain, p.adjust.method = "BH", pool.sd = FALSE)
pairwise.t.test(data.aph.t2$oqn.area, data.aph$Strain, p.adjust.method = "BH", pool.sd = FALSE)
pairwise.t.test(data.aph.t3$oqn.area, data.aph$Strain, p.adjust.method = "BH", pool.sd = FALSE)


```

##### Given the large n, calculate effect size of difference between mothers, then difference between daughters.
```{r}
#put cell area data in format for effect size calc
data.aph.u.t1 <-filter (data.aph.u, Condition == "Time00")
data.aph.u.t2 <-filter (data.aph.u, Condition == "Time06")
data.aph.u.t3 <-filter (data.aph.u, Condition == "Time17")
data.aph.s.t1 <-filter (data.aph.s, Condition == "Time00")
data.aph.s.t2 <-filter (data.aph.s, Condition == "Time06")
data.aph.s.t3 <-filter (data.aph.s, Condition == "Time17")
data.aph.scomp.t1 <-filter (data.aph.scomp, Condition == "Time00")
data.aph.scomp.t2 <-filter (data.aph.scomp, Condition == "Time06")
data.aph.scomp.t3 <-filter (data.aph.scomp, Condition == "Time17")

#calc effect size
cohen.d(data.aph.u.t2$oqn.area, data.aph.u.t1$oqn.area, paired = FALSE)
cohen.d(data.aph.u.t2$oqn.area, data.aph.u.t3$oqn.area, paired = FALSE)

cohen.d(data.aph.s.t2$oqn.area, data.aph.s.t1$oqn.area, paired = FALSE)
cohen.d(data.aph.s.t2$oqn.area, data.aph.s.t3$oqn.area, paired = FALSE)

cohen.d(data.aph.scomp.t2$oqn.area, data.aph.scomp.t1$oqn.area, paired = FALSE)
cohen.d(data.aph.scomp.t2$oqn.area, data.aph.scomp.t3$oqn.area, paired = FALSE)

cohen.d(data.aph.scomp.t1$oqn.area, data.aph.u.t1$oqn.area)

```

### Single cell time lapse imaging analysis, Figure 4

#### Read in the data and put into format useful for plotting and stats
```{r}
divratio <- read.csv('divratio-garner.csv', header = TRUE) %>%
    gather(strain, ratio, ura3:cdrS) %>%
    drop_na()

abirth <- read.csv('areabirth-garner.csv', header = TRUE) %>%
    gather(strain, abirth, ura3:cdrS) %>%
    drop_na()

adiv <- read.csv('areadiv-garner.csv', header = TRUE) %>%
    gather(strain, adiv, ura3:cdrS) %>%
    drop_na()


td <- read.csv('td-garner.csv', header = TRUE) %>%
    gather(strain, td, ura3:ftsZ2) %>%
    drop_na() 

abirth.adiv <- read.csv('abirth-adiv.csv', header = TRUE) 
abirth.adiv.wide<-read.csv('abirth-adiv-wide.csv', header = TRUE)

group.colors <- c(ura3="#000000", cdrS="#29AF7FFF", cdrL="#FDE725FF", ftsZ2="#453781FF")

```



#### Calculate cell area doubling time and plot distributions (Figure 4A)
```{r}


pdf("area_td.pdf", width = 6, height = 4)
ggplot(data = td, aes(x = td, stat(density), color = strain)) +
  geom_freqpoly(binwidth = 2, lwd = 1.25) +
  theme_light() +
  scale_color_manual(values = group.colors, labels = c(expression( italic("cdrS")), expression(italic("ftsZ2")), expression(italic("ura3")))) +
  theme(panel.grid = element_blank(), axis.text = element_text(size = 10), axis.title = element_text(size = 12)) +
  scale_x_continuous(expand = c(0,0), limits = c(0, 18)) +
  scale_y_continuous(expand = c(0,0)) +
  
  labs(x = 'Cell area doubling time (hr)', y = 'Relative frequency') 
  
dev.off()
```

#### Calculate stats for doubling time (text corresponding to fig 4A)
```{r}
#calculate means and standard deviation of cell doubling time distributions for each strain
td$td.rate <- 1/td$td

td.stats <-ddply(td, .(strain), summarize, td.geo = geoMean(td), median = median(td), rate.geo = geoMean(td.rate), sd = sd(td), sd.rate = sd(td.rate), n.obs = length(td), se = sd(td)/sqrt(n.obs))




td.stats

```

```{r}
# statistical tests. 
qqPlot(td$td) # not normally distributed, but given the critical limit theorem, can assume normality given that there are >40 observations for each strain.

td.wide <- read.csv('td-garner.csv', header = TRUE)

td.test<-aov(ura3 ~ cdrS*ftsZ2, data = td.wide)
summary(td.test) #differences between strains is not significant. 

```

#### Calculate effect size and confidence intervals given the large number of observations.
```{r}

#from https://cran.r-project.org/web/packages/sjstats/vignettes/anova-statistics.html and the sjstats package: "The eta-squared is the proportion of the total variability in the dependent variable that is accounted for by the variation in the independent variable. It is the ratio of the sum of squares for each group level to the total sum of squares. It can be interpreted as percentage of variance accounted for by a variable."

eta_sq(td.test, ci.lvl = .95) #most common measure of effect size

#only 0-0.1% of the variation in area doubling time (dependent variable) is explained by strain difference (independent). Looking at s and z2 together is 9.4% of variance. Larger, but also not relevant, because z2 and S deletion are in different strains, i.e. independent and not possibly interacting variables.
```


#### Calculate division area, birth area
```{r}
#divarea <- read.csv('garner_area_division.csv', header = TRUE)

adiv.stats <- ddply(adiv, .(strain), summarize, geomean = geoMean(adiv), median = median(adiv), sd = sd(adiv), nobs = length(adiv), cv = sd(adiv)/geoMean(adiv))

abirth.stats <- ddply (abirth, .(strain), summarize, geomean = geoMean(abirth), median = median(abirth), sd = sd(abirth), nobs = length(abirth), cv = sd(abirth)/geoMean(abirth))

#very large division area for cdrS, with high standard deviation.
```

#### Figure 4B 
```{r}
ura3ratio <- filter(divratio, strain == 'ura3')
cdrSratio <- filter(divratio, strain == 'cdrS')

ura3_dens <- density(ura3ratio$ratio, adjust = 0.5)
ura3_dens <- data.frame(x = ura3_dens$x, y = ura3_dens$y)



div_ura3 <- ggplot(ura3_dens, aes(x = x, y = 1, fill = y)) +
  geom_tile() +
  scale_fill_viridis() +
  theme_classic() +
  scale_x_continuous(expand = c(0, 0), limits = c(0, 1)) +
  scale_y_continuous(expand = c(0, 0)) +
  theme(panel.background = element_rect(fill = 'black'), 
        axis.ticks.y = element_blank(),
        axis.text.y = element_blank()) +
  labs(y = NULL, x = NULL) +
  NULL

#iv_ura3

cdrS_dens <- density(cdrSratio$ratio, adjust = 0.5)
cdrS_dens <- data.frame(x = cdrS_dens$x, y = cdrS_dens$y)

div_cdrS <- ggplot(cdrS_dens, aes(x = x, y = 1, fill = y)) +
  geom_tile() +
  scale_fill_viridis() +
  theme_bw() +
  scale_x_continuous(expand = c(0, 0), limits = c(0, 1)) +
  scale_y_continuous(expand = c(0, 0)) +
  theme(panel.background = element_rect(fill = 'black'), 
        axis.ticks.y = element_blank(),
        axis.text.y = element_blank(), 
        axis.title.x = element_text(size = 12),
        axis.text.x = element_text(size = 10)) +
  labs(y = NULL, x = 'Division ratio') +
  NULL

pdf("divratio-heatmap.pdf")
div_ura3 / div_cdrS
dev.off()

```

#### Figure 4C and D
```{r}
#http://www.sthda.com/english/wiki/be-awesome-in-ggplot2-a-practical-guide-to-be-highly-effective-r-software-and-data-visualization

pdf("a.pdf", width = 4, height = 8)


abirth.ggdot<-ggdotplot(abirth, x = "strain", y = "abirth", position = position_jitter(0.3),
          fill = "strain", color = "strain",  binwidth = 0.2, alpha = 0.5) +
    
    

  theme_light() +
  theme(panel.grid = element_blank()) +
  scale_y_continuous(expand = c(0,0), limits = c(0, 70)) +
  scale_color_manual(values = group.colors) +
  scale_fill_manual(values = group.colors) +
  stat_summary(fun.y = median, 
               fun.ymin = median,
               fun.ymax = median,
               geom = 'crossbar', width = 0.5, 
               aes(color = strain)) +
  theme( axis.text.x  = element_text(size = 10), axis.text.y = element_text(size = 10), axis.title = element_text(size = 12), legend.position = "none") +
  labs(x = 'Strain', y = 'Cell area at birth') +
  coord_flip() +
  NULL


adiv.ggdot<-ggdotplot(adiv, x = "strain", y = "adiv",
          fill = "strain", color = "strain", position = position_jitter(0.3), binwidth = 0.2, alpha = 0.5) +

  theme_light() +
  theme(panel.grid = element_blank()) +
  scale_y_continuous(expand = c(0,0), limits = c(0, 70)) +
  scale_color_manual(values = group.colors) +
  scale_fill_manual(values = group.colors) +
  stat_summary(fun.y = median, 
               fun.ymin = median,
               fun.ymax = median,
               geom = 'crossbar', width = 0.5, 
               aes(color = strain)) +
  theme( axis.text.x  = element_text(size = 10), axis.text.y = element_text(size = 10), axis.title = element_text(size = 12), legend.position = "none") +
  labs(x = 'Strain', y = 'Cell area at division') +
  coord_flip() +
    
  NULL

hist.b <- ggplot(data = abirth, aes(x = abirth, stat(density), color = strain)) +
  geom_freqpoly(binwidth = 2, lwd = 1) +
  theme_light() +
  scale_color_manual(values = group.colors) +
  theme(panel.grid = element_blank(), axis.text.x = element_blank(), axis.text.y = element_text(size = 10), legend.position = "none") +
  #scale_x_continuous(expand = c(0,0), limits = c(0, 18)) +
  #scale_y_continuous(expand = c(0,0)) +
  labs(x = '', y = 'Relative frequency') +
        
  #, labels = element_text(c("ura3", "cdrS"))
  NULL

 hist.d <- ggplot(data = adiv, aes(x = adiv, stat(density), color = strain)) +
  geom_freqpoly(binwidth = 2, lwd = 1) +
  theme_light() +
  scale_color_manual(values = group.colors, labels = element_text(c("ura3", "cdrS"))) +
  theme(panel.grid = element_blank(), axis.text.x = element_blank(), axis.text.y = element_text(size = 10), legend.position = "none") +
  #scale_x_continuous(expand = c(0,0), limits = c(0, 18)) +
  #scale_y_continuous(expand = c(0,0)) +
  labs(x = '', y = 'Relative frequency') +
  
  NULL
 
 grid.newpage()
grid.draw(rbind(ggplotGrob(hist.d), ggplotGrob(adiv.ggdot), ggplotGrob(hist.b), ggplotGrob(abirth.ggdot), size = "last"))
  #gridExtra::grid.arrange( hist.d, adiv.dot, hist.b,abirth.dot, ncol = 1, nrow = 4)

 # adiv.dot / abirth.dot

dev.off()
```


#### Statistical comparisons, mother and daughter cell area
```{r}
#put data in format usable by anova
ura.birth <- abirth.adiv.wide[ ,1:2]
ura.birth <- gather(ura.birth,  daughter, area)
colnames(ura.birth) <- c("which.daughter", "ura.d.area")

cdr.birth <- abirth.adiv.wide[ ,3:4]
cdr.birth <- gather (cdr.birth, daughter, area)
colnames(cdr.birth) <- c("which.daughter", "cdr.d.area")

ura.mom <- abirth.adiv.wide[ ,5]
cdr.mom <- abirth.adiv.wide[ ,6]

abirth.adiv.input <- as.data.frame(cbind(ura.birth$ura.d.area, cdr.birth$cdr.d.area, ura.mom, cdr.mom))
colnames(abirth.adiv.input)<-c("ura.d.area", "cdr.d.area", "ura.mom", "cdr.mom")

#test for normality
qqPlot (abirth.adiv$area) #No! 
qqPlot (log(abirth.adiv$area)) #not log normal - very far from normal. Even with ctrl limit, need a transformation.
abirth.adiv.checknorm<-bestNormalize(abirth.adiv$area) #check which transformation is best.

abirth.adiv.checknorm$chosen_transform #Ordered quantile normalization (OQN) is best normalization strategy
abirth.adiv.checknorm$norm_stats #look at the information about the distributions following each transform

```

#### Perform OQN on the mother / daughgter area data
```{r}
md.area.n<-orderNorm(abirth.adiv$area)
abirth.adiv$oqn.area<-predict(md.area.n)
hist(abirth.adiv$oqn.area, breaks = 20)
# data forced to normal distribution.
```


#### Pairwise Welch's test and effect size calculations on oqn-normalized mother and daughter areas
```{r}
pairwise.t.test(abirth.adiv$oqn.area, abirth.adiv$m.d.f, p.adjust.method = "BH", pool.sd = FALSE)

#calculate effect size of difference between mothers, then difference between daughters.


reverse.abirth.adiv<-dplyr::arrange(abirth.adiv, desc(m.d))

cohens_d(reverse.abirth.adiv, oqn.area ~ m.d, paired = FALSE)


```

#### Calculate stats for division ratio
```{r}
div.s.nearcenter <-filter (divratio, ratio <= 0.60 & ratio >= 0.30, strain == "cdrS")
div.s.nearpole <- filter (divratio, ratio >= 0.8 | ratio <= 0.2, strain == "cdrS")
dim (div.s.nearcenter) #14 of 30 cells divide offset from center
dim (div.s.nearpole) # 10 of 30 cells divide near the pole

ratio.stats<-ddply(divratio, .(strain), summarize, divratio.geo = geoMean(ratio), median = median(ratio), sd = sd(ratio), n.obs = length(ratio), cv = sd(ratio)/geoMean(ratio))

ratio.stats
```



#### Plot the division ratio histogram and raw data (lower subpanel 4B)
```{r} 

group.colors <- c(ura3="#000000", cdrS="#29AF7FFF")

#, ftsZ2="#453781FF"
pdf('divratio.pdf', width = 4, height = 4)

divratio.ggdot<-ggdotplot(divratio, x = "strain", y = "ratio", add = "mean_sd", 
          fill = "strain", color = "strain", position = position_jitter(0.03), binwidth = 0.01, alpha = 0.5) + 
  
  theme_light() +
  theme(panel.grid = element_blank()) +
  #scale_y_continuous(expand = c(0,0), limits = c(0, 70)) +
  scale_color_manual(values = group.colors) +
  scale_fill_manual(values = group.colors) +
  stat_summary (fun.y = median, 
               fun.ymin = median,
               fun.ymax = median,
               geom = 'crossbar', width = 0.5, 
               aes(color = strain)) +
  theme( axis.text.x  = element_text(size = 10), axis.text.y = element_text(size = 10, face = "italic"), axis.title = element_text(size = 12), legend.position = "none") +
  labs(x = 'Strain', y = 'Division ratio') + 
            coord_flip() +
  
  NULL
          
 
ratio_plot <- ggplot(data = divratio, aes(x = ratio, stat(density), 
                                              color = strain)) +
  geom_freqpoly(binwidth = 0.05, lwd = 1) +
  theme_light() +
  scale_color_manual(values = group.colors) +
  theme(panel.grid = element_blank(), axis.text.x  = element_blank(), legend.position = "none") +
  scale_x_continuous(expand = c(0,0)) +
  scale_y_continuous(expand = c(0,0)) +
  labs(x = '', y = 'frequency') +
  
  NULL
  
grid.newpage()
grid.draw(rbind(ggplotGrob(ratio_plot), ggplotGrob(divratio.ggdot), size = "last"))

dev.off()
#gridExtra::grid.arrange(ratio_plot, divratio.ggdot, ncol = 1, nrow = 2)

#divratio.dot 
#ratio_plot
```

### Nanostring gene expression analysis, Figure 6

#### Load the Nanostring count data and normalize it to expression in NRC-1 control strain
```{r}
#import the data
ns <- read.csv("count_corrected.csv", header = TRUE)

#subset the data and put it in the format needed for normalization
ns_tidy <- gather(ns, key = "Gene", value = "Count", colnames(ns)[8:30])
ns_tidy <- filter(ns_tidy, Condition %in% c("OD0.2", "OD0.7", "OD1.5", "OD2.0", "aphid", "release"))
NRC1_data <- filter(ns_tidy, Strain == "NRC1", Replicate == "A")
norm_tidy <- ns_tidy
norm_tidy$Relative_expression <- norm_tidy$Count

#normalize
for (i in 1:23) {
  std_count <- NRC1_data$Count[i]
  norm_tidy[norm_tidy$Gene == NRC1_data[i,]$Gene,]$Relative_expression <- 
    norm_tidy[norm_tidy$Gene == NRC1_data[i,]$Gene,]$Count / std_count
}

#log transform the values
norm_tidy$log.expr<-log(norm_tidy$Relative_expression)

#subset to focus on relevant data
core_set <- filter(norm_tidy, Strain %in% c("cdrS", "ura3")) %>%
   droplevels()

```

#### Plot all the genes, Supplementary Figure 5A
```{r}

group.colors <- c(ura3="#000000", cdrL="#7ed158", cdrS="#2f738c")

growth_all <- filter(core_set, Category %in% c(1:4))

pdf("growthall.pdf", width = 10, height = 8)
ggplot(growth_all) +
  geom_point(aes(x = Category, y = log.expr, color = Strain), 
              size = 1, alpha = 0.5) +
  geom_smooth(aes(x = Category, y = log.expr, 
                  color = Strain, fill = Strain),
              lwd = 0.5, span = 1, alpha = 0.25, method = "auto") +
  theme_bw() +
  scale_x_continuous(breaks=c(1, 2, 3, 4)) +
  facet_wrap(~Gene, scales = "free") +
  scale_color_manual(values = group.colors) +
  scale_fill_manual(values = group.colors) +
  labs(x = "OD600", y = "Relative expression") +
  theme(panel.grid.minor.y = element_blank())

dev.off()
```
#### Determine significantly differentially expressed genes using maSigPro package.
Gene expression in response to the growth curve and the ∆cdrS mutant are analyzed and plotted. In the following section, gene expression in response to aphidocholin treatment are analyzed and plotted.

##### Import the growth expression data and experimental design data objects for input to maSigPro
```{r}
#data
ns.data.masig.log<-read.csv("ns.data.masig.log.csv")

#design
ns.design.masig<-read.csv ("ns.design.masig.csv")
rownames(ns.design.masig) <- as.character(unlist(ns.design.masig[,1]))
ns.design.masig <- ns.design.masig[ ,-1 ]

```

##### Run the model
```{r}
#define regression model
 design <- make.design.matrix(ns.design.masig, degree = 2, time.col = 1, repl.col = 2, group.cols = c(3:ncol(ns.design.masig)))
design$groups.vector
#colnames(design$dis)<-c("Sample", "cdrSvsura3", "Time","TimexcdrS","Time2","Time2xcdrS")

```

```{r}
# find significant genes 
 fit <- p.vector(ns.data.masig.log, design, Q = 0.01, MT.adjust = "BH")
```

##### Examine the results
```{r}
#number of sig genes
fit$i #20 genes at Q val of 0.01. This is a lot but it is genes that change expression across the time course, not genes that are different between groups - that happens in the next step.
fit$alfa
```

```{r}
#determine genes significantly different between strains 
 tstep <- T.fit(fit, step.method = "backward", alfa = 0.01)
#look at the results
tstep$sol #shows the p.val of anova, rsq of the fit to the model, p.valor (p value of regression). Looks like  
tstep.results<-tstep$sol 
write.table (tstep.results, file = "tstep.results.masig.txt", sep = "\t")


```

```{r}
#Look at which genes are different between groups
sigs <- get.siggenes(tstep, rsq = 0.7, vars = "groups") #chose this cutoff because it is the median of the rsq from T.fit results
  names(sigs)
  names(sigs$sig.genes)
  sigs$sig.genes$cdrSvsura3
  sigs$sig.genes$ura3
  
```

##### Graphical display of results to get a sense of the clusters 
```{r}
#look at gene expression changes in parent control during growth
see.genes(sigs$sig.genes$ura3, show.fit = T, dis = design$dis, cluster.method = "hclust")

```

##### Write output files for supplementary table 7
```{r}
#save the list of genes differentially expressed in response to growth in the parent strain. Also make data frame for plotting for figure. The facet wrap labels for these 10 signif genes were highlighted manually in Illustrator in Supplementary Fig 3A.
ura3.sig<-sigs$sig.genes$ura3
ura3.sig.pvals<-ura3.sig$sig.pvalues
ura3.sig.profiles<-ura3.sig$sig.profiles
write.table(ura3.sig.pvals, file = "ura.masig.growth.pvals.txt", sep = "\t")
write.table(ura3.sig.profiles, file = "sig.genes.masigpro.ura.txt", sep = "\t")
```

```{r}
#save the list of genes differentially expressed in response to growth in the mutant strain.
cdr.sig<-sigs$sig.genes$cdrSvsura3
cdr.sig.pvals<-cdr.sig$sig.pvalues
cdr.sig.profiles<-cdr.sig$sig.profiles
write.table(cdr.sig.pvals, file = "cdr.masig.growth.pvals.txt", sep = "\t")
write.table(cdr.sig.profiles, file = "sig.genes.masigpro.cdr.txt", sep = "\t")

```

##### Plot the data for main text Figure 6A
```{r}
#Fig 5A (genes significantly differentially expressed in ∆S across the growth time course )
cdr.plot <- filter(growth_all, Gene %in% c("ftsZ1", "ftsZ2", "sojA", "ftsZ3"))
#cdr.sig.plot2 <- filter(growth_all, Gene %in% c("ftsZ3"))
group.colors <- c(ura3="#000000", cdrS="#2f738c")

pdf("fig5A.pdf" , width = 4, height = 4)
ggplot(cdr.plot) +
  geom_point(aes(x = Category, y = log.expr, color = Strain), 
              size = 1, alpha = 0.5) +
  geom_smooth(aes(x = Category, y = log.expr, 
                  color = Strain, fill = Strain),
            method = "auto", lwd = 1, span = 1, alpha = 0.25) +
  theme_bw() +
  scale_x_continuous(breaks=c(1, 2, 3, 4)) +
  facet_wrap(Gene ~., scales = "fixed", ncol = 2) +
  scale_color_manual(values = group.colors) +
  scale_fill_manual(values = group.colors) +
  labs(x = "Growth time point", y = "Relative expression") +
  theme(panel.grid.minor.y = element_blank(), axis.text = element_text(size = 10), axis.title = element_text(size = 12), strip.text = element_text(face = "italic"), legend.position = "none")  
  #ylim (-2, 1)



#grid.arrange(plot1, plot2, ncol = 2)

dev.off()
```

#### Aphidocholin differential gene expression analysis with maSigPro.

##### plot the data to make Supplementary Figure 5B
```{r}

#Supplementary Figure 3b

#subset the data to focus on aphidocholin treated samples
aph.ns <- filter(core_set, Category %in% c(5:6))


pdf("aphall.pdf", width = 5, height = 15)

#dotplots with raw data points shown.
ggplot(aph.ns, aes(x=Strain, y=log.expr, color = Strain)) + 
  geom_boxplot()+
  theme_bw() +
  facet_grid(Gene ~ Condition, scales = "free") +
 geom_jitter(size = 2, alpha = 0.5, position=position_jitter(0.2)) +
scale_color_manual(values = group.colors) +
  scale_fill_manual(values = group.colors) +
  labs(x = "strain", y = "Relative expression") 


dev.off()
```

##### Read in the data file and the design file
```{r}
#data
aph.data.log<- read.csv("aph.data.log.csv")

#design
aph.design<-read.csv ("aph.design.final.csv")

rownames(aph.design) <- as.character(unlist(aph.design[,1]))
aph.design <- aph.design[ ,-1 ]

#check to make sure that the design file rownames and data file column names match
rownames(aph.design)
colnames(aph.data.log)
dim(aph.design)
dim(aph.data.log)
```
##### Run the model for aphidocholin data
```{r}
#define regression model
 design.aph <- make.design.matrix(aph.design, degree = 2, time.col = 1, repl.col = 2, group.cols = c(3:ncol(aph.design)))
design.aph$groups.vector

```

```{r}
# find significant genes 
 fit.aph <- p.vector(aph.data.log, design.aph, Q = 0.01, MT.adjust = "BH")

```

##### Examine the results
```{r}
#number of sig genes
fit.aph$i #12 genes at Q val of 0.01. This is a lot but it is genes that change expression in response to treatment, not genes that are different between groups - that happens in the next step.
fit.aph$alfa
```


```{r}
#determine genes significantly different between strains 
 tstep.aph <- T.fit(fit.aph, step.method = "backward", alfa = 0.01)
#look at the results
tstep.aph$sol #shows the p.val of anova, rsq of the fit to the model, p.valor (p value of regression). 
tstep.aph.results<-tstep.aph$sol 
write.table (tstep.aph.results, file = "tstep.results.aph.txt", sep = "\t")


```


```{r}
#Look at which genes are different between groups
sigs.aph <- get.siggenes(tstep.aph, rsq = 0.7, vars = "groups") #chose this cutoff to be consistent with the growth time course analysis
  #names(sigs)
  #names(sigs$sig.genes)
  sigs.aph$sig.genes$cdrSvsura3
  sigs.aph$sig.genes$ura3
  
  #interesting! at alfa = 0.01 It says that Z2, sojABE (and of course VNG0194H, deleted in cdrS - a good pos ctrl for the masigpro method) are sig bw ura3 and cdrS in aph! 
```
##### Write output files for supplementary table 7
```{r}
#save the list of genes differentially expressed in response to growth in the parent strain. Also make data frame for plotting for figure. The facet wrap labels for these 10 signif genes were highlighted manually in Supplementary Fig 3A.
ura3.sig.aph<-sigs.aph$sig.genes$ura3
ura3.sig.aph.profiles<-ura3.sig.aph$sig.profiles
ura3.sig.aph.pvals<-ura3.sig.aph$sig.pvalues
write.table(ura3.sig.aph.pvals, file = "pvals.masigpro.ura.aph.txt", sep = "\t")
write.table(ura3.sig.aph.profiles, file = "sig.genes.masigpro.ura.aph.txt", sep = "\t")
```

```{r}
#save the list of genes differentially expressed in response to growth in the cdrS mutant strain.
cdr.sig.aph<-sigs.aph$sig.genes$cdrSvsura3
cdr.sig.aph.profiles<-cdr.sig.aph$sig.profiles
cdr.sig.aph.pvals<-cdr.sig.aph$sig.pvalues
write.table(cdr.sig.aph.pvals, file = "pvals.masigpro.cdr.aph.txt", sep = "\t")
write.table(cdr.sig.aph.profiles, file = "sig.genes.masigpro.cdr.aph.txt", sep = "\t")

```


##### Make figure 6B
```{r}
#make data frame focusing on aphid data with z1, z2, and sojABE
#Fig 5B
group.colors <- c(ura3="#000000", cdrS="#2f738c")
aph.z1z2soj <- filter(core_set, Condition %in% c("aphid", "release"), Gene %in% c("ftsZ1", "ftsZ2", "sojA", "sojB", "sojE")) %>%
  droplevels()

 

aph.z1z2soj$Strain <- factor(aph.z1z2soj$Strain, levels = c("ura3", "cdrS"))

 

#plots with raw data points shown.
pdf("fig5B.pdf", width = 4, height = 6)
ggplot(aph.z1z2soj, aes(x= Condition, y=log.expr, color = Strain)) + 
  geom_jitter(width = 0.2, alpha = 0.6) +
  facet_grid(Gene ~ Strain) +
  #geom_dotplot(alpha = 0.5, position=position_jitter(0.2), binaxis = "y", stackdir= "center", binwidth = 0.1) +
  stat_summary(fun.y = median, fun.ymin = median, fun.ymax = median,
               geom = "crossbar", width = 0.5,  fatten = 0.5) +
  theme_bw()+
  
  scale_color_manual(values = group.colors) +
  scale_fill_manual(values = group.colors) +
  labs(x = "strain", y = "Relative expression") 

 

 

dev.off()
```
##### Analyze the absolute number of mRNA molecules for ftsZ1 and ftsZ2 (main text description)
```{r}
#read in normalized counts file.
ns.cts <-  read.csv ("nanostring-normcounts.csv") %>%
 gather (gene, expression, VNG0194H:mrp) %>%
 filter (Strain == c("ura3", "cdrS")) #%>%
 #filter (gene == c("ftsZ1", "ftsZ2"))

ns.cts.stats<- ddply(ns.cts, .(Strain, gene), summarize, mean = mean(expression), sd = sd(expression))

write.table (ns.cts.stats, file = "ns.stats.txt", sep = "\t")

```

### ChIP-seq visualization with trackViewer (Figure 7).
See the ChIP-seq subfolder of this repository for ChIP-seq analysis code (read mapping, peak picking, and annotating peaks according to nearby genes).

See this helpful tutorial for additional ideas for using trackViewer: https://bioconductor.org/packages/release/bioc/vignettes/trackViewer/.


#### Import the files we will need to plot
```{r}

#These bam files are too large to host on github. Please generate them from the raw data at GEO accession number GSE148065 and the code on https://github.com/amyschmid/cdr. Files also available upon request.

log.bam1<-importBam("0195FLAG1log_IP_sorted.bam")
log.pks1 <- importScore("HBT-cdrL1-log-pks.bed", ranges = GRanges("NC_002607.1", IRanges(1,2e6)))

log.dat1<-coverageGR(log.pks1$dat)

log.bam3<-importBam("0195FLAG3log_IP_sorted.bam")
log.pks3 <- importScore("HBT-cdrL3-log-pks.bed", ranges = GRanges("NC_002607.1", IRanges(1,2e6)))

log.dat3<-coverageGR(log.pks3$dat)

stat.bam1<-importBam("0195FLAG1sta_IP_sorted.bam")
stat.pks1<-importScore("HBT-cdrL1-stat-pks.bed", ranges = GRanges("NC_002607.1", IRanges(1,2e6)))

stat.dat1<-coverageGR(stat.pks1$dat)

stat.bam3<-importBam("0195FLAG3sta_IP_sorted.bam")
stat.pks3<-importScore("HBT-cdrL3-stat-pks.bed", ranges = GRanges("NC_002607.1", IRanges(1,2e6)))

stat.dat3<-coverageGR(stat.pks3$dat)


hbt.genes<-importScore("hbt-genes-nostrand.bed", ranges = GRanges("NC_002607.1", IRanges(1,2e6)))

```

#### Make gene model
```{r}

my.txdb <- GenomicFeatures::makeTxDbFromGFF("20181113_hbt_GCF_000006805.1_ASM680v1_genomic.gff", format = "gff")

gr <- GRanges("NC_002607.1", IRanges(1,2e6))

some.genes <- GenomicFeatures::genes(my.txdb)

rtracklayer::export(some.genes, "hbt-genes.bed", format = "bed")
```


#### make the plot, supplementary Figure S5A
```{r}
#Show peaks detected across the chromosome in all replicates and phases of growth.
pdf("SF5A.pdf")
viewerStyle <- trackViewerStyle()
setTrackViewerStyleParam(viewerStyle, "margin", c(.1, .05, .02, .02))
vp <- viewTracks(trackList (log.pks1, log.pks3, stat.pks1, stat.pks3), 
                 gr=gr, viewerStyle=viewerStyle, 
                 autoOptimizeStyle=TRUE)


dev.off()
```

#### Make the plot ready for main text, Figure 7
```{r}
#make new tracks that allow overplotting
log<-log.pks1
log$dat2<-log.bam1$dat

stationary<-stat.pks1
stationary$dat2<-stat.bam1$dat


```

```{r}
#optimize the viewing style
optSty <- optimizeStyle(trackList(hbt.genes, stationary, log))
trackList <- optSty$tracks
viewerStyle <- optSty$style
```

```{r}
#make the plot 

pdf("fig07-zoomin.pdf")
setTrackStyleParam(trackList[[3]], "ylim", c(0, 200))
setTrackStyleParam(trackList[[2]], "ylim", c(0,200))
setTrackStyleParam(trackList[[1]], "ylim", c(0,50))


setTrackStyleParam(trackList[[1]], "ylabgp", list(cex=.8, col="black"))
## set cex to avoid automatic adjust
setTrackStyleParam(trackList[[2]], "ylabgp", list(cex=.8, col="black"))
setTrackStyleParam(trackList[[3]], "ylabgp", list(cex=.8, col="black"))
setTrackStyleParam(trackList[[1]], "marginBottom", .2)

setTrackStyleParam(trackList[[1]], "color", "grey")
setTrackStyleParam(trackList[[2]], "color", c("#7ed158", "black"))
setTrackStyleParam(trackList[[3]], "color", c("#7ed158", "black"))



setTrackViewerStyleParam(viewerStyle, "margin", c(.1, .05, .02, .02))
viewTracks(trackList, 
                 gr=gr.zoom,  viewerStyle=viewerStyle, operator = "+")
                 #autoOptimizeStyle=TRUE)

#output the plot to file
dev.off()

```



#### Make the plots for supplementary Figure S5B
```{r}
#make new tracks that allow overplotting
log3<-log.pks3
log3$dat2<-log.bam3$dat

stationary3<-stat.pks3
stationary3$dat2<-stat.bam3$dat
```


```{r}
#optimize the viewing style
optSty <- optimizeStyle(trackList(hbt.genes, stationary3, log3))
trackList <- optSty$tracks
viewerStyle <- optSty$style
```

```{r}
# Zoom in to plot the raw data for the cdrS promoter across the other replicates
pdf("SF5B.pdf")

setTrackStyleParam(trackList[[3]], "ylim", c(0, 600))
setTrackStyleParam(trackList[[2]], "ylim", c(0,200))
setTrackStyleParam(trackList[[1]], "ylim", c(0,50))


setTrackStyleParam(trackList[[1]], "ylabgp", list(cex=.8, col="black"))
## set cex to avoid automatic adjust
setTrackStyleParam(trackList[[2]], "ylabgp", list(cex=.8, col="black"))
setTrackStyleParam(trackList[[3]], "ylabgp", list(cex=.8, col="black"))
setTrackStyleParam(trackList[[1]], "marginBottom", .2)

setTrackStyleParam(trackList[[1]], "color", "grey")
setTrackStyleParam(trackList[[2]], "color", c("#7ed158", "black"))
setTrackStyleParam(trackList[[3]], "color", c("#7ed158", "black"))



setTrackViewerStyleParam(viewerStyle, "margin", c(.1, .05, .02, .02))
viewTracks(trackList, 
                 gr=gr.zoom,  viewerStyle=viewerStyle, operator = "+")
                 #autoOptimizeStyle=TRUE)

#output the plot to file



dev.off()

```

### Function of CdrS in other halophiles (Figure 8)

#### Read in the growth data 
```{r}
g <- read.delim ("OE_overnight-OD.txt")
head(g)
```
#### calculate summary stats
```{r}
g.stats <- ddply(g, plasmid ~ species, summarize, mean = mean(OD), sd = sd(OD), nobs = length(OD), cv = sd(OD)/mean(OD), sem = sd(OD)/sqrt(nobs))
g.stats
```

#### Plot the data (Figure 8B)
```{r}
#g$common.name_species <- paste (g$common.name, g$species, sep = "_")


  
group.colors <- c(vector = "#000000", cdrS ="#287D8E")

growth.plot <- ggplot(g, aes(x = common.name, y = OD,
                     fill = common.name, color = common.name)) +
  geom_dotplot(binaxis = 'y', 
               stackdir = 'center',
               dotsize = 5,
               binwidth = 0.03,
               alpha = 0.5) + 
  theme_light() +  
#  scale_fill_viridis_d(begin = 0, end = 0.75) +
#  scale_color_viridis_d(begin = 0, end = 0.75) +
  scale_color_manual(values = group.colors) +
  scale_fill_manual(values = group.colors) +
  scale_x_discrete(limits = rev(levels(as.factor(g$common.name)))) +
  scale_y_continuous(limits = c(0, 4)) +
  theme(panel.grid = element_blank(),
        legend.position = 'none',
        axis.text = element_text(size = 12),
        strip.text = element_text(size = 12)) +
  stat_summary(fun.y = median, 
               fun.ymin = median,
               fun.ymax = median,
               geom = 'crossbar', width = 0.4, lwd = 0.2,
               aes(group = common.name)) +
  labs(y = "OD600", x = NULL) + 
  
  facet_wrap( ~ species) 
 
#  guides(fill = guide_legend(override.aes = list(size = 0.3))) +
  NULL

#Hvplot + coord_flip()



ggsave("Figure_OE_growth-rev.pdf", width = 5, height = 2, dpi = 600)
#growth.plot
```

#### Read in the cell length and area data and format
```{r}
# first work with with data for Hfx volcanii (hv)
celldata.hv <- read.csv('20170606_Hv_cell_stats.csv', header = TRUE)
celldata.hv$Strain <- ordered(celldata.hv$Strain, levels = c('cdrS+', 'EV'))
celldata.hv$Strain <- revalue(celldata.hv$Strain, c('EV'='empty_vector'))
celldata.hv$Strain <- revalue(celldata.hv$Strain, c('cdrS+'='cdrS_overexpression'))

celldata.hm <- read.csv('20170601_Hm_overexpression.csv', header = TRUE)
celldata.hm$Strain <- ordered(celldata.hm$Strain, levels = c('cdrS+', 'EV'))
celldata.hm$Strain <- revalue(celldata.hm$Strain, c('EV'='empty_vector'))
celldata.hm$Strain <- revalue(celldata.hm$Strain, c('cdrS+'='cdrS_overexpression'))

# then work with data for Hfx mediterranei (hm)
```

#### Generate dot plots of the cell area data for Hv (Supplementary Figure 8)
```{r}
group.colors <- c(empty_vector = "#000000", cdrS_overexpression ="#287D8E")

Hvplot <- ggplot(celldata.hv, aes(x = Strain, y = Area_micron,
                     fill = Strain, color = Strain)) +
  geom_dotplot(binaxis = 'y', 
               stackdir = 'center',
               dotsize = 5,
               binwidth = 0.05,
               alpha = 0.4,
               position = 'jitter') + 
  theme_light() +  
#  scale_fill_viridis_d(begin = 0, end = 0.75) +
#  scale_color_viridis_d(begin = 0, end = 0.75) +
  scale_color_manual(values = group.colors) +
  scale_fill_manual(values = group.colors) +
  scale_x_discrete(limits = rev(levels(as.factor(celldata.hv$Strain))),
                   labels = c("vector", "cdrS+")) +
  scale_y_continuous(limits = c(0, 150)) +
  theme(panel.grid = element_blank(),
        legend.position = 'none',
        axis.text = element_text(size = 12),
        axis.title.y = element_blank(),
        axis.text.y = element_blank()) +
  stat_summary(fun.y = median, 
               fun.ymin = median,
               fun.ymax = median,
               geom = 'crossbar', width = 1, lwd = 0.1,
               aes(group = Strain)) +
  labs(y = expression(paste("Area (", mu, m^2, ")", sep = "")), x = NULL) +
#  guides(fill = guide_legend(override.aes = list(size = 0.3))) +
  NULL

#Hvplot + coord_flip()



#ggsave("Figure_Hv_OE.pdf", width = 4, height = 5, dpi = 600)

```


#### Generate dot plots of the cell area data for Hm (Supplementary Figure 8)
```{r}
Hmplot <- ggplot(celldata.hm, aes(x = Strain, y = Area_micron,
                    fill = Strain, color = Strain)) +
  geom_dotplot(binaxis = 'y', 
               stackdir = 'center',
               dotsize = 5,
               binwidth = 0.05,
               alpha = 0.4,
               position = 'jitter') + 
  theme_light() +  
#  scale_fill_viridis_d(begin = 0, end = 0.75) +
#  scale_color_viridis_d(begin = 0, end = 0.75) +
  scale_color_manual(values = group.colors) +
  scale_fill_manual(values = group.colors) +
  scale_x_discrete(limits = rev(levels(as.factor(celldata.hm$Strain))),
                   labels = c("vector", "cdrS+")) +
  scale_y_continuous(limits = c(0,150)) + 
  theme(panel.grid = element_blank(),
        legend.position = 'none',
        axis.text = element_text(size = 12)) +
  stat_summary(fun.y = median, 
               fun.ymin = median,
               fun.ymax = median,
               geom = 'crossbar', width = 1, lwd = 0.1,
               aes(group = Strain)) +
  labs(y = expression(paste("Area (", mu, m^2, ")", sep = "")), x = NULL) +
#  guides(fill = guide_legend(override.aes = list(size = 0.3))) +
  NULL

#Hmplot + coord_flip()

#ggsave("Figure_Hm_OE.pdf", width = 4, height = 5, dpi = 600)

pdf("hfx_oe_area.pdf")
grid.newpage()
grid.draw(cbind(ggplotGrob(Hmplot), ggplotGrob(Hvplot), size = "last"))

dev.off()
```

#### Calculate summary stats for Hv data (reported in main text)
```{r}
#summary stats
hv.stats <- ddply(celldata.hv, .(Strain), summarize, geomean.area = geoMean(Area_micron), median.area = median(Area_micron), sd.area = sd(Area_micron), nobs.area = length(Area_micron), cv.area = sd(Area_micron)/geoMean(Area_micron), geomean.length = geoMean(Length_micron), median.length = median(Length_micron), sd.length = sd(Length_micron), nobs.length = length(Length_micron), cv.length = sd(Length_micron)/geoMean(Length_micron))

#make the first part of table 2
write.table (hv.stats, file = "hv.stats.txt", sep = "\t") 
```

#### Calculate summary stats for Hm data (reported in main text)
```{r}
hm.stats <- ddply(celldata.hm, .(Strain), summarize, geomean.area = geoMean(Area_micron), median.area = median(Area_micron), sd.area = sd(Area_micron), nobs.area = length(Area_micron), cv.area = sd(Area_micron)/geoMean(Area_micron), geomean.length = geoMean(Length_micron), median.length = median(Length_micron), sd.length = sd(Length_micron), nobs.length = length(Length_micron), cv.length = sd(Length_micron)/geoMean(Length_micron))

#make the second part of table 2s
write.table (hm.stats, file = "hm.stats.txt", sep = "\t")

```

#### Perform statistical tests: is cdrS overexpression strain significantly larger than vector control? 

##### test for normality
```{r}
qqPlot (celldata.hm$Area_micron) #no, but it looks like non-normality it's driven by a few outliers.
qqPlot (celldata.hv$Area_micron) #no, also a few outliers. 

library(referenceIntervals)

out.hm <- cook.outliers(celldata.hm$Area_micron)$outliers #use cook's distance to detect outliers
i <- which(celldata.hm$Area_micron %in% out.hm)
ggplot(celldata.hm[-i, ], aes(sample = Area_micron)) +
  stat_qq() +
  stat_qq_line()

out.hv <- cook.outliers(celldata.hm$Area_micron)$outliers #use cook's distance to detect outliers
i <- which(celldata.hv$Area_micron %in% out.hm)
ggplot(celldata.hv[-i, ], aes(sample = Area_micron)) +
  stat_qq() +
  stat_qq_line()
#still extremely skewed. need transform.
```

##### decide on best transform
```{r}
hm.checknorm<-bestNormalize(celldata.hm$Area_micron) #check which transformation is best.
hm.checknorm$chosen_transform #Ordered quantile normalization (OQN) is best normalization strategy
hm.checknorm$norm_stats #look at the information about the distributions following each transform


hv.checknorm<-bestNormalize(celldata.hm$Area_micron) #check which transformation is best.
hv.checknorm$chosen_transform #Ordered quantile normalization (OQN) is best normalization strategy
hv.checknorm$norm_stats #look at the information about the distributions following each transform
```

#### Perform OQN on the hv and hm area data
```{r}
hv.area.n<-orderNorm(celldata.hv$Area_micron)
celldata.hv$oqn.area<-predict(hv.area.n)
hist(celldata.hv$oqn.area, breaks = 20)
# data forced to normal distribution.

hm.area.n<-orderNorm(celldata.hm$Area_micron)
celldata.hm$oqn.area<-predict(hm.area.n)
hist(celldata.hm$oqn.area, breaks = 20)
# data forced to normal distribution.
```

#### Pairwise Welch's test and effect size calculations on oqn-normalized hv and hm areas
```{r}
celldata.hm.mt<-filter(celldata.hm, Strain == "empty_vector")
celldata.hm.cdrs<-filter(celldata.hm, Strain == "cdrS_overexpression")
t.test(celldata.hm.mt$oqn.area, celldata.hm.cdrs$oqn.area, p.adjust.method = "BH", pool.sd = FALSE)

celldata.hv.mt<-filter(celldata.hv, Strain == "empty_vector")
celldata.hv.cdrs<-filter(celldata.hv, Strain == "cdrS_overexpression")
t.test(celldata.hv.mt$oqn.area, celldata.hv.cdrs$oqn.area, p.adjust.method = "BH", pool.sd = FALSE)
#calculate effect size of difference between mothers, then difference between daughters.

```

##### Given the large n, calculate effect size of difference between mothers, then difference between daughters.
```{r}
#put celldata in format for effect size calc
oqnarea.hm<- as.data.frame(cbind(celldata.hm.mt$oqn.area, celldata.hm.cdrs$oqn.area))
colnames(oqnarea.hm) <- c("mt.oqnarea", "cdrs.oqnarea")

#calc effect size
cohen.d(oqnarea.hm$cdrs.oqnarea, oqnarea.hm$mt.oqnarea, paired = FALSE)


#put celldata in format for effect size calc
oqnarea.hv<- as.data.frame(cbind(celldata.hv.mt$oqn.area, celldata.hv.cdrs$oqn.area))
colnames(oqnarea.hv) <- c("mt.oqnarea", "cdrs.oqnarea")

#calc effect size
cohen.d(oqnarea.hv$cdrs.oqnarea, oqnarea.hv$mt.oqnarea, paired = FALSE)

```


